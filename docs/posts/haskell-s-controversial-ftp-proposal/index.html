<!DOCTYPE html>
<html lang="en" data-theme=""><head>
    <title> Tom Janssens | Foldable for non-Haskellers: Haskell&#39;s controversial FTP proposal </title>

    
    <meta charset="utf-8"><meta name="generator" content="Hugo 0.80.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description" content="Random opinionated blurbs">
    
    <link rel="stylesheet"
          href="https://tojans.me/css/style.min.9a6700e4461b50dccdddfc4f81dc65d77e7fca22c35665e398a0c36568db59c7.css"
          integrity="sha256-mmcA5EYbUNzN3fxPgdxl135/yiLDVmXjmKDDZWjbWcc="
          crossorigin="anonymous"
          type="text/css">
    
    <link rel="stylesheet"
        href="https://tojans.me/css/markupHighlight.min.cc84ed683057cc175ddfa738ea6ba2d5c882b95cb64f50bf9be918cb3791887b.css"
        integrity="sha256-zITtaDBXzBdd36c46mui1ciCuVy2T1C/m&#43;kYyzeRiHs="
        crossorigin="anonymous"
        type="text/css">
    
    <link rel="stylesheet" 
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" 
    integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" 
    crossorigin="anonymous" />

    
    <link rel="shortcut icon" href="https://tojans.me/favicons/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="https://tojans.me/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://tojans.me/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://tojans.me/favicons/favicon-16x16.png">

    <link rel="canonical" href="https://tojans.me/posts/haskell-s-controversial-ftp-proposal/">

    
    
    
    
    <script type="text/javascript"
            src="https://tojans.me/js/anatole-header.min.d8599ee07b7d3f11bafbac30657ccc591e8d7fd36a9f580cd4c09e24e0e4a971.js"
            integrity="sha256-2Fme4Ht9PxG6&#43;6wwZXzMWR6Nf9Nqn1gM1MCeJODkqXE="
            crossorigin="anonymous"></script>


    
        
        
        <script type="text/javascript"
                src="https://tojans.me/js/anatole-theme-switcher.min.e289e9ebb2a4e7a7f895859c8a2b0da2de1ec73f22cea58d8475aa0597023837.js"
                integrity="sha256-4onp67Kk56f4lYWciisNot4exz8izqWNhHWqBZcCODc="
                crossorigin="anonymous"></script>
    
    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://tojans.me/images/site-feature-image.png"/>

<meta name="twitter:title" content="Foldable for non-Haskellers: Haskell&#39;s controversial FTP proposal"/>
<meta name="twitter:description" content="In the Haskell world, there is currently a big fuss about the &ldquo;Foldable/Traversable in Prelude&rdquo;-proposal."/>

</head>
<body><div class="sidebar . ">
    <div class="logo-title">
        <div class="title">
            <img src="https://tojans.me/images/profile.jpg" alt="profile picture">
            <h3 title=""><a href="/">Tom&#39;s ramblings</a></h3>
            <div class="description">
                <p>Random opinionated blurbs</p>
            </div>
        </div>
    </div>
    <ul class="social-links">
        
            <li>
                <a href="http://www.twitter.com/tojans" rel="me" aria-label="Twitter">
                    <i class="fab fa-twitter fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="http://www.linkedin.com/in/tomjanssens" rel="me" aria-label="Linkedin">
                    <i class="fab fa-linkedin fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="http://www.github.com/tojans" rel="me" aria-label="GitHub">
                    <i class="fab fa-github fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="mailto:tom@corebvba.be" rel="me" aria-label="e-mail">
                    <i class="fas fa-envelope fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="/index.xml" rel="me" aria-label="RSS">
                    <i class="fas fa-rss fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
    <div class="footer">
        <div class="by_farbox">&copy; Tom Janssens  2021 </div>
    </div>
</div>
<div class="main">
    <div class="page-top  . ">
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
    </a>
    <ul class="nav" id="navMenu">
        
        
            
            <li><a 
                   href="/posts/"
                        
                   title="">Blog posts</a></li>
        
            
            <li><a 
                   href="/contact/"
                        
                   title="">Contact</a></li>
        
        
        
            <li class="theme-switch-item">
                <a class="theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
</div>

    <div class="autopagerize_page_element">
        <div class="content">
    <div class="post  . ">
        <div class="post-content">
            
            <div class="post-title">
                <h3>Foldable for non-Haskellers: Haskell&#39;s controversial FTP proposal</h3>
                
            </div>

            <p>In the Haskell world, there is currently a big fuss about
<a href="https://wiki.haskell.org/Foldable_Traversable_In_Prelude">the &ldquo;Foldable/Traversable in Prelude&rdquo;-proposal</a>.</p>
<p><strong>Edit:</strong> For the record: it <strong>was</strong> a proposal, and has been implemented in the current version of Haskell (GHC)</p>
<p>As a non-Haskeller, you probably wonder what all the fuss is about.</p>
<h2 id="first-things-first-some-context">First things first: some context</h2>
<p>In most languages, you have functions to iterate over a <code>sequence</code> / <code>array</code> / <code>iterable</code> / <code>list</code>, for example in C# (assuming we have an array called <code>values</code>)</p>
<div class="highlight"><pre class="chroma"><code class="language-C#" data-lang="C#"><span class="kt">int</span><span class="p">[]</span> <span class="n">values</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[]</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">};</span>

<span class="k">foreach</span><span class="p">(</span><span class="kt">var</span> <span class="n">v</span> <span class="k">in</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>In Haskell, we usually refer to an <code>sequence</code> with a <code>list</code>, and the example code would look like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-Haskell" data-lang="Haskell"><span class="nf">values</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

<span class="nf">mapM_</span> <span class="n">print</span> <span class="n">values</span>
</code></pre></div><p>Let&rsquo;s say we need a function that concatenates several sequences of the type <code>a</code>.</p>
<p>In somewhat contrived C# we would write it like this (assuming we use arrays):</p>
<div class="highlight"><pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">static</span> <span class="n">Ta</span><span class="p">[]</span> <span class="n">Concat</span><span class="p">&lt;</span><span class="n">Ta</span><span class="p">&gt;(</span><span class="n">Ta</span><span class="p">[][]</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">res</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Ta</span><span class="p">[]{};</span>
    <span class="k">foreach</span><span class="p">(</span><span class="kt">var</span> <span class="n">v</span> <span class="k">in</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">res</span> <span class="p">=</span> <span class="n">res</span><span class="p">.</span><span class="n">Concat</span><span class="p">(</span><span class="n">v</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="p">[][]</span> <span class="n">values</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[][]</span> <span class="p">{</span>
    <span class="k">new</span> <span class="kt">int</span><span class="p">[]</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">},</span>
    <span class="k">new</span> <span class="kt">int</span><span class="p">[]</span> <span class="p">{</span><span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">}</span>
<span class="p">};</span>

<span class="n">Concat</span><span class="p">(</span><span class="n">values</span><span class="p">);</span>
<span class="c1">// results in [1,2,3,4,5,6]
</span></code></pre></div><p>In Haskell we&rsquo;d write it like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-Haskell" data-lang="Haskell"><span class="nf">values</span> <span class="ow">::</span> <span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span>
<span class="nf">values</span> <span class="ow">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>

<span class="nf">concat</span> <span class="ow">::</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">concat</span> <span class="n">vals</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">val</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="n">val</span> <span class="o">++</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span> <span class="n">vals</span>

<span class="nf">concat</span> <span class="n">values</span>
<span class="c1">-- results in [1,2,3,4,5,6]</span>
</code></pre></div><blockquote>
<h3 id="optional-reading-type-definitions">Optional reading: type definitions</h3>
<p>The odd <code>someName :: a -&gt; b -&gt; c</code> you see on top of the function implementations is a type definition.</p>
<ul>
<li>The thing before the <code>::</code> defines the name of the function</li>
<li>The last term defines the type of return value.</li>
<li>Other terms define type of the function&rsquo;s parameters.</li>
</ul>
<p>A few examples:</p>
<ul>
<li><code>value :: Int</code>
<ul>
<li>Takes no input</li>
<li>Returns a value of the type <code>Int</code></li>
<li>Example: <code>value = 5</code></li>
</ul>
</li>
<li><code>values :: [Int]</code>
<ul>
<li>Takes no input</li>
<li>Returns a <code>list</code> of values of the type <code>Int</code></li>
<li>Example: <code>values = [1,2,3]</code></li>
</ul>
</li>
<li><code>values :: [[Int]]</code>
<ul>
<li>Takes no input</li>
<li>Returns a <code>list</code> of a <code>list</code> of values of the type <code>Int</code></li>
<li>Example: <code>values = [[1,2,3],[4,5,6]]</code></li>
</ul>
</li>
<li><code>decrement :: Int -&gt; Int</code>
<ul>
<li>Takes a parameter of the type <code>Int</code></li>
<li>Returns a value of the type <code>Int</code></li>
<li>Example: <code>decrement x = x - 1</code></li>
</ul>
</li>
<li><code>add :: Int -&gt; Int -&gt; Int</code>
<ul>
<li>Takes two parameters of the type <code>Int</code></li>
<li>Returns a value of the type <code>Int</code></li>
<li>Example: <code>addTwoInts x y = x + y</code></li>
</ul>
</li>
<li><code>length :: [a] -&gt; Int</code>
<ul>
<li>Takes a <code>list</code> of <code>a</code> where <code>a</code> can be any type</li>
<li>Returns a value of the type <code>Int</code></li>
<li>This function works on any <code>list</code>, no matter which is the type of <code>a</code>:
<ul>
<li><code>length [4,5,6]</code> returns <code>3</code></li>
<li><code>length ['a','b','c']</code> also returns <code>3</code></li>
<li><code>length &quot;abc&quot;</code> also returns <code>3</code>, as a <code>String</code> is a synonym for a <code>list</code> of <code>Char</code></li>
</ul>
</li>
</ul>
</li>
<li><code>decrement :: Num a =&gt; a -&gt; a</code>
<ul>
<li>Requires a type <code>a</code> to implement the <code>Num</code> type class.
<ul>
<li>A <code>type class</code> is somewhat similar to an <code>interface</code> in other languages.</li>
<li>The type class <code>Num</code> implements arithmetic operators for the type.</li>
</ul>
</li>
<li>Takes a parameter of the type <code>a</code></li>
<li>Returns a value of the type <code>a</code></li>
<li>Example: <code>decrement x = x - 1</code>.</li>
</ul>
</li>
</ul>
<p>Now back to the main content&hellip;</p>
</blockquote>
<h2 id="what-is-a-foldable-anyway">What is a <code>Foldable</code> anyway</h2>
<p>Notice that in the Haskell example the <code>concat</code> function is defined for a <code>list</code> of <code>lists</code>, i.e. <code>concat :: [[a]] -&gt; [a]</code>.</p>
<p>There is a well known functional paradigm called a <code>fold</code>, which allows you to convert something that has multiple values into a single value.</p>
<p>Let&rsquo;s take the example of a <code>sum</code>:</p>
<ul>
<li>Starts with an initial <code>accumulator</code> value of <code>0</code></li>
<li>Adds each of the sequence&rsquo;s <code>values</code> one by one to the <code>accumulator</code></li>
<li>returns the final <code>accumulator</code>.</li>
</ul>
<p>This would be the code:</p>
<div class="highlight"><pre class="chroma"><code class="language-Haskell" data-lang="Haskell"><span class="nf">sum</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">sum</span> <span class="n">vals</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">val</span> <span class="ow">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">val</span><span class="p">)</span> <span class="mi">0</span> <span class="n">vals</span>

<span class="nf">product</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">product</span> <span class="n">vals</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">val</span> <span class="ow">-&gt;</span> <span class="n">acc</span> <span class="o">*</span> <span class="n">val</span><span class="p">)</span> <span class="mi">1</span> <span class="n">vals</span>
</code></pre></div><p>Now, imagine that you have a <code>binary tree structure</code> where a <code>node</code> contains either:</p>
<ul>
<li>a node with a left and a right child node</li>
<li>a leaf with a value</li>
<li>an empty node:</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Haskell" data-lang="Haskell"><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span>
            <span class="o">|</span> <span class="kt">Leaf</span> <span class="n">a</span>
            <span class="o">|</span> <span class="kt">Empty</span>
</code></pre></div><p>And that you need to get the sum and product for all these leaves. This goes as follows:</p>
<ul>
<li><code>acc</code> refers to <code>the currently accumulated value</code></li>
<li><code>ln</code> refers to a <code>left child node</code></li>
<li><code>rn</code> refers to a <code>right child node</code></li>
<li><code>val</code> refers to a <code>value of a leaf node</code></li>
</ul>
<p>If it&rsquo;s a <code>node</code>, the <code>XXXacc</code> recursively calls itself to add or multiply it&rsquo;s children&rsquo;s values,
if it&rsquo;s a leaf, it just adds/multiplies the value with the accumulator.</p>
<div class="highlight"><pre class="chroma"><code class="language-Haskell" data-lang="Haskell"><span class="nf">sum</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">sum</span> <span class="n">tree</span> <span class="ow">=</span> <span class="n">sumAcc</span> <span class="n">tree</span> <span class="mi">0</span>
  <span class="kr">where</span>
    <span class="n">sumAcc</span> <span class="n">node</span> <span class="n">acc</span> <span class="ow">=</span>
      <span class="kr">case</span> <span class="n">node</span> <span class="kr">of</span>
        <span class="kt">Leaf</span> <span class="n">val</span>   <span class="ow">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">val</span>
        <span class="kt">Node</span> <span class="n">ln</span> <span class="n">rn</span> <span class="ow">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="p">(</span><span class="n">sumAcc</span> <span class="n">ln</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">sumAcc</span> <span class="n">rn</span><span class="p">)</span>
        <span class="kt">Empty</span>      <span class="ow">-&gt;</span> <span class="n">acc</span>

<span class="nf">prod</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">prod</span> <span class="n">tree</span> <span class="ow">=</span> <span class="n">prodAcc</span> <span class="n">tree</span> <span class="mi">1</span>
  <span class="kr">where</span>
    <span class="n">prodAcc</span> <span class="n">node</span> <span class="n">acc</span> <span class="ow">=</span>
      <span class="kr">case</span> <span class="n">node</span> <span class="kr">of</span>
        <span class="kt">Leaf</span> <span class="n">val</span>   <span class="ow">-&gt;</span> <span class="n">acc</span> <span class="o">*</span> <span class="n">val</span>
        <span class="kt">Node</span> <span class="n">ln</span> <span class="n">rn</span> <span class="ow">-&gt;</span> <span class="n">acc</span> <span class="o">*</span> <span class="p">(</span><span class="n">prodAcc</span> <span class="n">ln</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">prodAcc</span> <span class="n">rn</span><span class="p">)</span>
        <span class="kt">Empty</span>      <span class="ow">-&gt;</span> <span class="n">acc</span>
</code></pre></div><p>You might see a pattern here. Haskellers <strong>hate</strong> copy paste programming, so they extract what is common.</p>
<p>If you take a look at what is common and different, you see only two differences:</p>
<ul>
<li>We use <code>+</code> and <code>*</code></li>
<li>We start from <code>0</code> and <code>1</code></li>
</ul>
<p>So a Haskeller would extract this functionality, and as this is a common pattern, we&rsquo;d call it a <code>Foldable</code> type class instance. Code would look like this</p>
<div class="highlight"><pre class="chroma"><code class="language-Haskell" data-lang="Haskell"><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span>
            <span class="o">|</span> <span class="kt">Leaf</span> <span class="n">a</span>
            <span class="o">|</span> <span class="kt">Empty</span>

<span class="kr">instance</span> <span class="kt">Foldable</span> <span class="kt">Tree</span> <span class="kr">where</span>
  <span class="c1">-- some code here</span>

<span class="nf">sum</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">sum</span> <span class="n">tree</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">val</span> <span class="ow">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">val</span><span class="p">)</span> <span class="mi">0</span> <span class="n">tree</span>

<span class="nf">prod</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">prod</span> <span class="n">tree</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">val</span> <span class="ow">-&gt;</span> <span class="n">acc</span> <span class="o">*</span> <span class="n">val</span><span class="p">)</span> <span class="mi">1</span> <span class="n">tree</span>
</code></pre></div><blockquote>
<h3 id="optional-reading-cleaning-up-haskell-code">Optional reading: cleaning up Haskell code</h3>
<p>Even though this is compilable Haskell code, and the program would work, you would never see
Haskell code like this in the wild. Haskellers apply some concepts to make the source
code even leaner to read; let me show you how:</p>
<ul>
<li>Let&rsquo;s take a look at this expression:
<ul>
<li><code>sum tree = foldl (\acc val -&gt; acc + val) 0 tree</code></li>
</ul>
</li>
<li>The type declaration is <code>sum :: Num a =&gt; Tree a -&gt; a</code> so we know the function
<ul>
<li>Requires <code>a</code> to implement the <code>Num</code> type class.</li>
<li>Takes a <code>Tree</code> that contains values of the type <code>a</code></li>
<li>Returns a value of the type <code>a</code></li>
</ul>
</li>
<li>In Haskell you can &ldquo;convert operators into functions&rdquo; by putting parenthesis around them, so
<ul>
<li><code>\acc val -&gt; acc + val</code> is equivalent to  <code>\acc val -&gt; (+) acc val</code></li>
<li>The type for this accumulator function is <code>Num a =&gt; a -&gt; a -&gt; a</code></li>
</ul>
</li>
<li>As both parameters now have the same order, we can apply a concept called currying (i.e. omit the last parameters if they are the same), so
<ul>
<li><code>\acc val -&gt;  (+) acc val</code> is equivalent to <code>\acc -&gt; (+) acc</code>.</li>
<li>The type for this accumulator function remains <code>Num a =&gt; a -&gt; a -&gt; a</code></li>
</ul>
</li>
<li>we curry it once more, so
<ul>
<li><code>\acc -&gt;  (+) acc</code> is equivalent to <code>\ -&gt; (+)</code>.</li>
<li>The type for this accumulator function remains <code>Num a =&gt; a -&gt; a -&gt; a</code></li>
</ul>
</li>
<li>Calling a function with no parameters is the same as calling the function directly, so
<ul>
<li><code>\ -&gt; (+)</code> is equivalent to <code>(+)</code></li>
<li>The type for this accumulator function remains <code>Num a =&gt; a -&gt; a -&gt; a</code></li>
</ul>
</li>
<li>Replacing this in the original declaration, we now we end up with
<ul>
<li><code>sum tree = foldl (+) 0 tree</code></li>
<li>The type declaration still is <code>sum :: Num a =&gt; Tree a -&gt; a</code></li>
</ul>
</li>
<li>As the function&rsquo;s parameters are similar once again, we can omit the <code>tree</code> part, so
<ul>
<li><code>sum tree = foldl (+) 0 tree</code> is equivalent to <code>sum = foldl (+) 0</code></li>
<li>The type declaration still is <code>sum :: Num a =&gt; Tree a -&gt; a</code></li>
</ul>
</li>
</ul>
<p>So a Haskeller would most likely end up with the following code, while maintaining the same types:</p>
<div class="highlight"><pre class="chroma"><code class="language-Haskell" data-lang="Haskell"><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span>
           <span class="o">|</span> <span class="kt">Leaf</span> <span class="n">a</span>
           <span class="o">|</span> <span class="kt">Empty</span>

<span class="kr">instance</span> <span class="kt">Foldable</span> <span class="kt">Tree</span> <span class="kr">where</span>
 <span class="c1">-- some code here</span>

<span class="nf">sum</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">sum</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span>

<span class="nf">prod</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">prod</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="mi">1</span>
</code></pre></div></blockquote>
<blockquote>
<h4 id="this-has-one-important-consequence-when-you-are-doing-haskell">This has one important consequence when you are doing Haskell:</h4>
<p>In order to figure out what parameters a function requires, you need to look at it&rsquo;s type
declaration, and not at the implementation.</p>
<p>So both the <code>sum</code> and the <code>product</code> take a <code>Tree</code> of <code>a</code>, and return an <code>a</code>, where <code>a</code> implements the <code>Num</code> type class. This is the reason why Haskellers care so much about type definitions.</p>
</blockquote>
<h2 id="back-to-the-controversial-ftp-proposal">Back to the controversial <code>FTP</code>-proposal</h2>
<p>Haskell works with a system they call <code>modules</code> (referred to as <code>namespaces</code> in other languages).</p>
<p>By default, Haskell applications import a module called <code>Prelude</code>, which contains a lot of handy helper functions, for example the <code>sum</code> function we mentioned in the beginning :</p>
<div class="highlight"><pre class="chroma"><code class="language-Haskell" data-lang="Haskell"><span class="nf">sum</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">sum</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span>
</code></pre></div><p>Now, as Haskellers do not only want to use <code>sum</code> on a <code>list</code>, but also on any <code>Foldable</code> instance, they decided to change the type signature to this:</p>
<div class="highlight"><pre class="chroma"><code class="language-Haskell" data-lang="Haskell"><span class="nf">sum</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Foldable</span> <span class="n">t</span><span class="p">,</span> <span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">sum</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span>
</code></pre></div><p>Because there exists a <code>Foldable</code> instance for a  <code>list</code>, we can use the &ldquo;Foldable <code>sum</code>&rdquo; function, and remove the <code>sum</code> function that only works on lists.</p>
<h2 id="so-what-is-controversial-about-this-proposal">So what is controversial about this proposal?</h2>
<p><strike>People come from different backgrounds. When you talk about a <code>list</code>, people new in Haskell think about a sequence, and they can imagine what is happening.</p>
<p>However, due to the new signature (i.e. the <code>Foldable</code> thing), people new to Haskell might have a hard time to get started with Haskell, because they need to learn about
the concept of <code>Foldable</code> first, so the barrier of entry is getting larger.</p>
<p>In my opinion, it might be a little harder to grasp at first, but if, as a beginner, you are willing to just accept a few things without knowing why they are like they are,
the barrier to entry shouldn&rsquo;t be much higher than before.</strike></p>
<h3 id="update">UPDATE</h3>
<p>I assumed I understood what all the fuss was about, but apparently I did not. Luckily, <a href="https://twitter.com/bitemyapp">@bitemyapp</a> went the extra mile to explain while it was wrong:</p>
<blockquote class="twitter-tweet" lang="nl"><p lang="en" dir="ltr">Either and (,) in Haskell are not arbitrary&#10;&#10;<a href="https://t.co/2yJ1NBjMvS">https://t.co/2yJ1NBjMvS</a></p>&mdash; Chris Allen (@bitemyapp) <a href="https://twitter.com/bitemyapp/status/656273487267389440">20 oktober 2015</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>I&rsquo;d suggest you to read his article, but I&rsquo;ll give you the recap here:</p>
<p>Next to a <code>Foldable</code>, we also have a <code>Functor</code>. A <code>Functor</code> is something that you can <code>map over</code>, a structure that contains zero, one or more values. An example in GHCI:</p>
<div class="highlight"><pre class="chroma"><code class="language-Haskell" data-lang="Haskell"><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">inc</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span><span class="p">)</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">inc</span> <span class="mi">5</span>
<span class="mi">6</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="n">inc</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="n">inc</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">5</span><span class="p">)</span>
<span class="kt">Just</span> <span class="mi">6</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="n">inc</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="n">inc</span> <span class="p">(</span><span class="kt">Right</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">Right</span> <span class="mi">5</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="n">inc</span> <span class="p">(</span><span class="kt">Left</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">Left</span> <span class="mi">3</span>
</code></pre></div><p>Just think of this as a <code>map</code> or <code>select (C#)</code> statement. In the example above we have the following statements:</p>
<ul>
<li><code>let inc = (1 +)</code>
<ul>
<li>is of the type <code>inc :: Num a =&gt; a -&gt; a</code>, so it takes a <code>Num</code> instance, and adds <code>1</code> to it?</li>
</ul>
</li>
<li><code>inc 5</code>
<ul>
<li>returns <code>6</code></li>
</ul>
</li>
<li><code>fmap inc [1,2,3]</code>
<ul>
<li>returns <code>[2,3,4]</code></li>
<li>the container is a <code>List</code>, and the values in the list are <code>Num</code> instances.</li>
<li>the type signature for <code>fmap</code> is : <code>fmap (a-&gt;b) -&gt; [a] -&gt; [b]</code></li>
<li><code>fmap</code> takes a transformation function and a list, and returns a <code>List</code> containing the transformed values in the same order.</li>
<li>For a <code>list</code>, Haskell&rsquo;s <code>fmap</code> is equivalent to <code>map</code>, which is equivalent to a C# <code>select</code> statement.</li>
<li>In C#, <code>fmap</code> could be implemented for a list as <code>List&lt;Tb&gt; fmap&lt;Ta,Tb&gt;(Func&lt;Ta,Tb&gt; transform,List&lt;Ta&gt; list) =&gt; list.Select(transform).ToList()</code>.</li>
<li><code>Bifunctors</code>:
<ul>
<li>The <code>Maybe</code> type is a type that either represents a value or nothing.
<ul>
<li>this type was introduced to avoid null checking in all of your code.</li>
<li>values are represented using <code>Just a</code> where a can be any value.</li>
<li>nothing is represented using <code>Nothing</code>.</li>
<li>when you want to change the value of a <code>Maybe</code>, you typically only want to change it, when it contains a value. If it does not contain a value, you just want to do nothing with it.</li>
<li>how do we change the value of something in a container when using Haskell? Exactly: using <code>fmap</code></li>
<li><code>fmap inc (Just 5)</code>
<ul>
<li>returns <code>Just 6</code>, so it applied the <code>inc</code> function to the value of the <code>Maybe</code></li>
</ul>
</li>
<li><code>fmap inc Nothing</code>
<ul>
<li>returns <code>Nothing</code>, because it doesn&rsquo;t make any sense to apply changes to a &ldquo;null value&rdquo;</li>
</ul>
</li>
<li>let&rsquo;s say we have a var called <code>maybeVal</code>, that has the type <code>Maybe Num</code>, so it is either <code>Nothing</code> or <code>Just x</code> where x is a number.</li>
<li>if we want to either increment the value if it&rsquo;s defined, or just return a <code>0</code> if it is not, we could do it like this:</li>
<li><code>maybe 0 inc maybeVal</code>
<ul>
<li>if <code>maybeVal</code> is <code>Nothing</code> it uses the first argument : <code>0</code>
<ul>
<li><code>maybe 0 inc Nothing</code> returns <code>0</code></li>
</ul>
</li>
<li>if <code>maybeVal</code> has a value (<code>Just 5</code>), it applies the <code>inc</code> function to the value and returns that value, i.e. <code>6</code>
<ul>
<li><code>maybe 0 inc (Just 5)</code> returns <code>6</code></li>
</ul>
</li>
<li><code>fmap</code> is the <code>Functor</code> implementation, <code>maybe</code> is the <code>Bifunctor</code> implementation.</li>
</ul>
</li>
</ul>
</li>
<li>the <code>Either</code> type
<ul>
<li>Now, avoiding <code>null</code> checks everywhere is fun and all, but what if you would like to return some kind of error message in case a value is not defined?</li>
<li>For this we have the <code>Either a b</code> type, that can return 2 different types:
<ul>
<li>It can <code>Left a</code>, where <code>Left a</code> is typically an error message</li>
<li>It can return a <code>Right b</code>, where <code>Right b</code> is similar to a <code>Just b</code>, so this contains the value.</li>
<li>Let&rsquo;s say we have a function to parse a <code>date</code> from a <code>string</code>. We want it to return either the date, or an error message.
<ul>
<li>this would be the type of the function: <code>parseDateFromString :: String -&gt; Either Error Date</code></li>
<li>this would be equivalent to <code>Either&lt;Error,Date&gt; parseDateFromString(String)</code></li>
<li>in case there is a problem with the parsing we&rsquo;d get return value like this: <code>Left (Error &quot;Invalid date format; expected YYYY/MM/DD&quot;)</code></li>
<li>in case there is no problem  with the parsing we&rsquo;d get the value like this: <code>Right (Date 2015 10 20)</code></li>
</ul>
</li>
<li>What if we would like to print the year if it&rsquo;s a valid year, or display the error when it is not? Let&rsquo;s assume we have a value <code>eitherErrorOrDate</code>
<ul>
<li>we would call <code>either displayError printYear eitherErrorOrDate</code>
<ul>
<li>the type of <code>eitherErrorOrDate</code> would be <code>Either Error Date</code></li>
<li>for now, just take my word for it: a type of <code>IO ()</code> means: <code>something that interacted with the outside world, but didn't return any value</code></li>
<li>the type of the function <code>displayError</code> would be <code>Error -&gt; IO ()</code>, so it takes an error, and implies a changed world when executed.</li>
<li>the type of the function <code>printYear</code> would be <code>Date -&gt; IO ()</code>, so it takes an error, and implies a changed world when executed.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="now-whats-wrong-with-the-controversial-ftp-proposal">Now what&rsquo;s wrong with the controversial FTP proposal:</h3>
<p>In a <code>Maybe</code> or an <code>Either</code>, it makes sense that you only want to <code>map</code> to the <code>Just</code> value or the <code>Right</code> value.</p>
<p>Now, let&rsquo;s say you have a <code>Tuple</code>, and would map over this:</p>
<ul>
<li>A tuple has the type <code>(a,b)</code></li>
<li>So when you <code>fmap</code> <code>inc</code> over <code>(1,2)</code>, you&rsquo;d expect a <code>(2,3)</code>, correct?</li>
<li>Well, you don&rsquo;t : GHCI returns a <code>(1,3)</code></li>
<li>This is because a tuple can contain 2 different types, f.e. <code>(&quot;Hello&quot;,4)</code></li>
<li>As an <code>fmap</code> can only take one type as an input parameter, they decided to go for the second element, so <code>fmap inc (&quot;Hello&quot;,4)</code> returns <code>(&quot;Hello&quot;, 5)</code>.</li>
<li>This doesn&rsquo;t make sense, as the first element might be just as important in a tuple as the other, so this shouldn&rsquo;t have been a <code>Functor</code> in the first place.</li>
</ul>
<p>Thank you Chris for taking the time to explain this!</p>
</div>
        <div class="post-footer">
            <div class="info">
                
                <span class="separator"><a class="tag" href="/tags/development/">Development</a><a class="tag" href="/tags/haskell/">Haskell</a></span>

            </div>
        </div>

        
    </div>


        </div>
    </div>
</div><div class="footer">
	<hr class="thin" />
	<div class="pure-menu pure-menu-horizontal pure-menu-open">
		<ul class="footer-menu">
		
		</ul>
	</div>

	<p>&copy; 2021. All rights reserved. </p>
</div>

<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-41936060-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>
</body>

</html>
